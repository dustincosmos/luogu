/*
题目描述
小Z想给班里的同学拍一张合影，为此需要先让大家排好队伍。他希望大家站成 k 排，并规定了每排的人数，保证每一排的人数都不多于后面一排的人数。

这时小Z发现队伍看起来还是乱糟糟的，原因是大家的身高互不相同。于是，他希望排头对齐，每位同学都比自己正后方的同学以及排头方向的同学矮。

排完以后，善于思考的小Z还想知道一共有多少种排法。

例如，大家排成 3 排，且从后往前每排分别是 3、2、1 人，就有以下 16 种排法（每个数代表将所有同学身高从高到低排序后该同学的排名）：



可是班里一共有 n 个人，小Z算不出来了，希望你帮帮他。

输入格式
第一行包含一个整数 k。

第二行包含 k 个整数，表示从后往前每排的人数。

输出格式
一行，包含一个整数，表示队伍排列的方案数。

输入输出样例
输入 #1复制
3
3 2 1
输出 #1复制
16
输入 #2复制
5
1 1 1 1 1 
输出 #2复制
1
说明/提示
【数据规模】

对于 30% 的数据，n ≤ 10。

对于另外 30% 的数据，只有最后一排超过 1 个人。

对于 100% 的数据，1 ≤ k ≤ 5，1 ≤ n ≤ 30，方案数小于 2^32。
*/
#include<bits/stdc++.h>
using namespace std;
long long f[31][31][31][31][31];
int data[5]={0};
long long dp(int a,int b,int c,int d,int e)
{
    long long tem=0;
    if(f[a][b][c][d][e]!=0)
        return f[a][b][c][d][e];
    if(a>b)
        tem+=dp(a-1,b,c,d,e);
    if(b>c)
        tem+=dp(a,b-1,c,d,e);
    if(c>d)
        tem+=dp(a,b,c-1,d,e);
    if(d>e)
        tem+=dp(a,b,c,d-1,e);
    if(e>0)
        tem+=dp(a,b,c,d,e-1);
    f[a][b][c][d][e]=tem;
    return tem;
}

int main()
{
    int k,a,b,c,d,e;
    cin>>k;
    for(int i=0;i<k;i++)
        cin>>data[i];
    a=data[0],b=data[1],c=data[2],d=data[3],e=data[4];
    f[1][0][0][0][0]=f[1][1][0][0][0]=f[1][1][1][0][0]=f[1][1][1][1][0]=f[1][1][1][1][1]=1;
    dp(a,b,c,d,e);
    cout<<f[a][b][c][d][e];
    system("pause");
    return 0;
}